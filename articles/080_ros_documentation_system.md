---
tip: translate by openai@2023-05-28 11:14:54
...
---
    layout: default
    title: ROS 2 Documentation System
    permalink: articles/ros_documentation_system.html
    abstract:
      This article describes the proposed system for doing documentation for ROS 2.
    author: '[William Woodall](https://github.com/wjwwood)'
    date_written: 2015-01
    last_modified: 2016-02
    published: false
    Authors: {{ page.author }}
    Date Written: {{ page.date_written }}
    Last Modified: {% if page.last_modified %}{{ page.last_modified }}{% else %}{{ page.date_written }}{% endif %}
---


This document is meant to capture the results of discussions about the way we (the ROS 2 developers) would like documentation to work in ROS 2 and polish those results into a proposal.

> 这份文件旨在捕捉我们（ROS 2 开发者）希望ROS 2中文档的工作方式的讨论结果，并将这些结果整理成一份提案。

It is likely that this document should be refined and made into a REP once a suitable design is settled on.

> 这份文件可能需要在确定合适的设计之后进行细化和制定成一个REP。

## Glossary


- **Documentation Engine**: Any tool which takes in information and produces documentation for the end user, e.g. Sphinx, Doxygen, a custom documentation script, etc.

> -**文档引擎**：任何用于接受信息并为最终用户生成文档的工具，例如Sphinx、Doxygen、自定义文档脚本等。

- **Documentation Job**: A series of actions taken to provide documentation prerequisites, do documentation, validate the result, and finally transfer the result to a hosting solution, i.e. what to do on the build farm.

> - **文档工作**：采取一系列行动以提供文档先决条件，进行文档，验证结果，最后将结果转移到托管解决方案，即在构建农场上要做什么。

- **Documentation Process**: A well defined process by which any package can be introspected and then have all of its documentation generated by running the correct documentation engines with the correct settings, i.e. how to build documentation for any package.

> -**文档流程**：一个定义明确的流程，通过运行正确的文档引擎，使用正确的设置来检查任何软件包，并生成所有文档，即如何为任何软件包构建文档。

- **Documentation System**: The cumulation of all components of documentation including: describing what to document, the documentation job, the documentation process, the documentation inputs and outputs for every package, and supporting tools.

> - **文档系统**：包括描述文档内容、文档工作、文档流程、每个包的文档输入和输出以及支持工具的所有组件的累积。

## Documentation System Overview


Probably the principal difference between this proposed design and the existing ROS 1 system is the belief that general documentation about a package should be captured in the package as version controlled plain text files.

> 可能这个提议的设计和现有的ROS 1系统的主要区别在于相信关于一个包的一般文档应该作为版本控制的纯文本文件存储在包中。

### Wiki Versus Static Documentation


In this case "general" documentation is what you would typically find on the ROS 1 wiki and consists of things like detailed descriptions of packages, links to external references, images and diagrams, descriptions of nodes, launch files, and other common components of ROS packages.

> 在这种情况下，“通用”文档就是您通常会在ROS 1维基上找到的内容，包括详细描述的软件包、链接到外部参考资料、图像和图表、节点描述、启动文件以及ROS软件包的其他常见组件。

This is to distinguish these things from other kinds of documentation like Code API documentation, which is often written along side the code as comments, extracted automatically, and so therefore traditionally kept in plain text formats and version controlled with the code already.

> 这是为了区分这些东西和其他类型的文档，比如代码API文档，通常是作为注释写在代码旁边，自动提取，因此通常会以纯文本格式保存，并与代码一起进行版本控制。

This "general" documentation could also encompass other types of documentation or memorandum like tutorials, API reviews, and discussions, but these types of documentation could also be kept in a separate system like a wiki.

> 这种"一般"文档也可以包括其他类型的文档或备忘录，比如教程、API评论和讨论，但这些类型的文档也可以保存在另一个系统中，比如维基百科。


In ROS 1, a conscious decision was made to push as much of the documentation into the ROS 1 wiki as possible and in ROS 2 we would like to diverge from that and suggest that more documentation should be version controlled with the code.

> 在ROS 1中，我们有意识地决定将尽可能多的文档推送到ROS 1 wiki中，而在ROS 2中，我们希望能够偏离这一点，建议将更多的文档与代码一起版本控制。

The main reason, as far as we can gather, for this decision in ROS 1 was to make it as easy as possible for non developers to contribute changes to the documentation.

> 这个决定在ROS 1中的主要原因是尽可能让非开发人员容易地为文档做出更改。

It is still the case for outsiders that changing documentation in a source repository is more difficult than documentation which is located in a wiki.

> 对外人来说，更改源代码库中的文档仍然比位于维基上的文档更加困难。

However, it seems that times have changed in this respect, and that the gap between editing a wiki page and getting a change in a source repository has narrowed.

> 然而，在这方面似乎时代已经发生了变化，编辑wiki页面和在源代码库中得到更改的差距已经缩小了。

This is mostly due to improvements in the open source contribution practices on services like GitHub and BitBucket and the proliferation of both the Pull Request pattern and the "Edit in GitHub/BitBucket" buttons on generated documentation pages.

> 这主要是由于GitHub和BitBucket等服务上的开源贡献实践的改进以及拉取请求模式和生成文档页面上的“在GitHub/BitBucket中编辑”按钮的普及所致。


In exchange for moving some types of documentation into the source repository, we believe that maintaining changes in documentation across different ROS versions and different package versions will become easier.

> 为了把一些文档移动到源代码库，我们相信在不同的ROS版本和不同的软件包版本中维护文档的变化会变得更容易。

Additionally, the systems for doing code documentation will allow for more robust cross referencing to and from the code API documentation.

> 此外，用于进行代码文档的系统将允许更强大的与代码API文档的互相引用。

Finally, by doing this kind of documentation in code, it brings the ROS community's recommended practices closer to common practice for modern open source software projects, where the last few years have seen a migration from wiki's to statically generated documentation which comes from plain text files in the version control system.

> 最后，通过在代码中进行这种文档记录，它使ROS社区推荐的实践更接近现代开源软件项目的常规实践，过去几年中，wiki已经从静态生成的文档中迁移到版本控制系统中的纯文本文件。

### Risks of Static Documentation


There are some risks associated with using static documentation over something more dynamic like a wiki.

> 使用静态文档而不是像维基百科这样的动态文档会有一些风险。

As mentioned before the barrier to entry to contributions may be too high for some users, especially on documentation which does not need review for each change.

> 在之前提到的，参与的门槛可能对一些用户来说太高了，特别是对于不需要每次更改都要审查的文档。

Another potential issue is in documenting packages which would like to straddle multiple ROS distributions.

> 另一个潜在问题是文档化想要跨越多个ROS发行版的软件包。

This happens with code too, where a package would ideally have one line of versions and one development branch for several similar ROS distributions.

> 这也发生在代码中，理想情况下，一个包应该有一行版本和一个开发分支，用于几个类似的ROS发行版。

Doing so cuts down on the number branches and amount of forward and back porting required which reduces the overall developer load.

> 这样做可以减少分支数量和前后移植所需的工作量，从而降低开发人员的负担。

By doing more documentation in source it may become harder to maintain these ROS agnostic development branches.

> 通过在源代码中做更多的文档，维护ROS不可知开发分支可能变得更加困难。

This essentially becomes a trade-off in how easy it is to document packages with large or small changes between ROS distributions.

> 这本质上成为在ROS分发之间大或小变化的软件包文档化的容易程度之间的权衡。


Another risk of this proposal is that it may discourage usage of a wiki in scenarios where a wiki would be appropriate.

> 这项提议的另一个风险是，它可能会阻碍在适当情况下使用维基的情况。

The intention of this proposal is not to suggest that wiki's should not be used, but instead means it will be up to the developer to decide what kinds of documentation are best suited for difference documentation options.

> 本提案的意图并不是建议不使用wiki，而是由开发人员来决定哪种文档最适合不同的文档选项。

For example, documentation which bridges multiple packages is not well suited to being contained in one package's documentation and therefore may work better in a wiki style system.

> 例如，跨多个包的文档不适合放在一个包的文档中，因此可能更适合使用维基式系统。

However, by encouraging developers to make use of static documentation generation tools, there will be less need for heavy infrastructure, mirroring the documentation will be easier, and documentation will be more tightly coupled to the code.

> 然而，通过鼓励开发人员使用静态文档生成工具，就不需要复杂的基础设施，镜像文档也会更容易，文档也会更紧密地与代码相关联。

### Other Goals of the Documentation System


One desired goal of the documentation system is to generate a standard landing page for all packages which are released or documented.

> 一个文档系统的期望目标是为所有发布或记录的包生成一个标准的入口页面。

Similar to how the [PackageHeader](http://wiki.ros.org/WikiMacros#PackageHeader) wiki macro works in ROS 1, this page would summarize the items common to all packages.

> 类似于ROS 1中[PackageHeader](http://wiki.ros.org/WikiMacros#PackageHeader)维基宏的工作方式，本页面将总结所有包共有的项目。

These items would consist of information extracted from the package manifest, the package's README file, and other external resources like the build farm and the ROS distribution file.

> 这些项目将包括从包清单、包的README文件以及像构建农场和ROS发行文件等其他外部资源中提取的信息。

This page can also contain dynamically generated information about the package which transcends one version of the package or one ROS distribution, e.g. it could list all of the ROS distributions in which the package has been released.

> 这个页面也可以包含关于软件包的动态生成信息，这些信息可以超越一个软件包版本或一个ROS发行版，例如它可以列出软件包已发布的所有ROS发行版。

This page would also be able to automatically collect and link to resources in the packages.

> 这个页面也能自动收集和链接到包中的资源。

For example, it could link to documentation for messages or external services like wiki's and other kinds of external documentation.

> 例如，它可以链接到消息或外部服务的文档，比如wiki和其他类型的外部文档。

Ideally this page would be easy to produce locally as part of the normal documentation of the package and is not something special that is only done on the ROS infrastructure.

> 理想情况下，这个页面可以轻松地作为包的正常文档的一部分本地生成，而不是只在ROS基础设施上完成的特殊操作。

Generating it locally would allow the developer to preview all of the content for their package before publishing it to the publicly hosted infrastructure.

> 本地生成它将允许开发人员在将其发布到公共托管基础架构之前预览其包的所有内容。

To support this goal, there would need to be a documentation engine which is run by every ROS package regardless of any other general documentation a developer wishes to create.

> 为了支持这个目标，每个ROS包都需要运行一个文档引擎，无论开发人员希望创建任何其他一般文档。


Another goal of the system is to support general documentation of ROS packages in source repositories rather than in a separately version controlled system like a wiki.

> 系统的另一个目标是支持ROS包在源代码仓库中的普通文档，而不是在像维基一样的独立版本控制系统中。

To achieve this the system would need to supply the developers with ROS specific documentation tools.

> 要实现这一目标，系统需要向开发人员提供ROS特定的文档工具。

These kinds of tools would do things like cross reference to ROS messages automatically or make the information from the package manifest accessible in the documentation engine.

> 这些工具可以像自动交叉参考ROS消息或使包清单中的信息可在文档引擎中访问一样做事情。

This kind of tooling would need to be provided for each documentation engine which we expect users to use for general documentation, which would be a burden to support.

> 这种工具需要为我们期望用户用于一般文档的每个文档引擎提供，这将是一种支持的负担。

Therefore, it would make sense to have a recommended documentation engine for general documentation of packages, limiting the need for tools in many documentation engines.

> 因此，为了减少对多种文档引擎的需求，为包的一般文档提供推荐文档引擎是有意义的。


There are some other tasks which every package _may_ need to perform based on its contents.

> 根据其内容，可能还有一些其他的任务需要执行。

Typically this is related to documenting special parts of the package, things like messages, launch files, or node parameter descriptions.

> 通常，这与记录软件包的特殊部分有关，例如消息、启动文件或节点参数说明。

For messages (include services and actions), no extra action may be necessary since there is a build time generation step at which point documentation could also be generated.

> 对于消息（包括服务和操作），由于有构建时间生成步骤，因此不需要进行额外的操作，也可以在此时生成文档。

However, there is no such step in the normal build process where generating documentation for things launch files is appropriate so packages which contain these things will need to generate documentation using some documentation engine, regardless of any other general documentation the developer creates.

> 然而，正常构建过程中没有为启动文件生成文档的步骤，因此包含这些内容的包需要使用某种文档引擎生成文档，而不管开发人员创建了什么其他一般文档。

Even if the developer does not reference their own launch files or messages, another package may wish to, so the documentation for these things should always be created.

> 即使开发者没有参考自己的启动文件或消息，另一个包也可能希望这样做，因此这些东西的文档应该总是创建的。

## Default Documentation Engine


Based on the above goals, it seems clear that one or more default documentation engines will be required.

> 根据以上目标，似乎很明显需要一个或多个默认文档引擎。

The above goals mostly apply to ROS packages, but not necessarily any package our tool chain can build, i.e. third party CMake, Python, or autotools packages.

> 以上目标主要适用于ROS包，但不一定适用于我们的工具链可以构建的任何包，即第三方CMake、Python或autotools包。

The distinction is that our tool chain should not automatically assume a default engine, but rather the qualities that make a package a "ROS" package, i.e. depending on a ROS documentation package, should determine whether or not the default documentation engine is exercised by the tool chain.

> 我们的工具链的区别在于，不应自动假定默认引擎，而是应该根据使一个包成为“ROS”包的特性，即是否依赖ROS文档包，来决定工具链是否使用默认文档引擎。

This allows the tool chain to be agnostic to these additional items which are common to all ROS packages, but not necessarily all packages.

> 这使得工具链对所有ROS包中的这些附加项目具有不可知性，尽管不一定适用于所有包。


While it would be convenient to have one default documentation engine, it may be necessary to have several for either technical reasons or for modularity.

> 虽然有一个默认的文档引擎会很方便，但出于技术原因或模块化的需要，可能需要多个文档引擎。

For simplicity, this article will describe a system with a single documentation system, with the understanding that this default documentation engine may have inputs from previous processes or that it might aggregate several different tools as part of its execution.

> 为了简单起见，本文将描述一个具有单一文档系统的系统，理解为该默认文档引擎可能会从先前的过程中获得输入，或者它可能会将多个不同的工具作为其执行的一部分来聚合。


So for ROS packages this default engine would always be run and would be responsible for generating the package's landing page and for generating documentation for any special items like launch files and other common items which can be automatically documented.

> 所以对于ROS软件包，这个默认引擎将始终被运行，负责生成软件包的首页，并且为任何特殊项目（如启动文件和其他可以自动文档化的常见项目）生成文档。

If the developer does not provide any configurations for this default documentation engine then a boiler plate configuration which generates a landing page would be created for them automatically.

> 如果开发人员没有为这个默认文档引擎提供任何配置，那么会自动为他们创建一个生成着页的锅炉板配置。

This would allow all packages to have some minimal documentation with zero configuration by the developer.

> 这将允许所有的软件包在不需要开发者配置的情况下，拥有一些最低限度的文档。

The developer would be able to generate this boiler plate documentation and configuration if they wanted to modify it, for instance to add something to the default landing page (much like you would on the ROS 1 wiki below the PackageHeader macro).

> 开发人员如果想要修改它，比如在默认的登录页面上添加一些东西（就像你在ROS 1维基上下面的PackageHeader宏一样），就可以生成这个锅炉板文档和配置。

However, the system should do some minimal check to ensure that the landing page looks and feels consistent with other packages, e.g. ensure the equivalent to the "PackageHeader" is on the landing page and that the ROS theme is being used or extended.

> 然而，系统应该做一些最低限度的检查，以确保登陆页面看起来和感觉与其他包一致，例如确保“PackageHeader”的等价物出现在登陆页面上，并且使用或扩展ROS主题。


When selecting a default engine, some things should be considered:

> 在选择默认引擎时，应该考虑以下几点：


- The engine should be easy to extend (in order to provide the aforementioned tooling to the developer).

> 引擎应该容易扩展（以便为开发者提供上述工具）。

- The engine's syntax should be easy to learn (on the level of the current ROS 1 wiki's syntax).

> 引擎的语法应该容易学习（达到当前ROS 1 wiki语法的水平）。

- The engine must be design for general purpose documenting (not just automatic code documenting).

> 引擎必须设计用于通用文档（不仅仅是自动代码文档）。

- The engine should have a cross referencing system to help maintain links between packages.

> 引擎应该有一个交叉引用系统来帮助维护包之间的链接。


Based on that, feasible options would include Sphinx, Doxygen, or a custom Python script that just expands an `empy` template.

> 基于此，可行的选项包括Sphinx、Doxygen或者只是扩展`empy`模板的自定义Python脚本。

### Sphinx as a Default Documentation Engine


Sphinx is a compelling solution since it can be easily extended with Python and has a cross referencing system.

> 斯芬克斯是一个引人注目的解决方案，因为它可以用Python轻松扩展，并具有交叉引用系统。

It uses the ReStructured Text (rst) standard for its markup language, which is fairly easy to learn, but can be cumbersome in some scenarios.

> 它使用重新组织文本(rst)标准作为其标记语言，这种语言相对容易学习，但在某些情况下可能会比较繁琐。

The benefit of rst and Sphinx is that its "directive" system provides a flexible way to extend the markup language without relying on an external template system.

> 优势在于rst和Sphinx的“指令”系统提供了一种灵活的方式，可以在不依赖外部模板系统的情况下扩展标记语言。

Philosophically, Sphinx is oriented around creating documentation rather than extracting documentation from code.

> 从哲学上讲，Sphinx更多的是为了创建文档而不是从代码中提取文档。

### Doxygen as a Default Documentation Engine


Doxygen would also be a good choice since it has a good cross reference system and can parse markdown files for general purpose documentation.

> Doxygen也是一个不错的选择，因为它具有很好的交叉引用系统，可以解析markdown文件用于一般文档。

Markdown is arguably simpler and easier to read than rst, but it also is less flexible since it does not have a built in system for extension.

> Markdown可以说比rst更简单易读，但由于没有内置的扩展系统，它的灵活性也较少。

Doxygen has manually extended Markdown to include cross referencing, but more complicated tasks would need to be done using a template engine in conjunction with Markdown, similar to how Jekyll works.

> Doxygen已手动扩展了Markdown，以支持交叉引用，但更复杂的任务需要使用模板引擎与Markdown结合使用，就像Jekyll一样。

Doxygen excels at extracting documentation from code, especially C++ and Java, and has a lot of its features geared toward describing and automatically organizing code documentation.

> Doxygen 在从代码中提取文档方面表现出色，尤其是C++和Java，它有许多特性有助于描述和自动组织代码文档。

Its extension system is arguably less approachable than Sphinx's since they are done in C++ and scripting of Doxygen commands is limited to argument aliasing.

> 它的扩展系统可以说比Sphinx的不那么容易接近，因为它们是用C++完成的，而且Doxygen命令的脚本化仅限于参数别名。

### Custom Tool as a Default Documentation Engine


A custom tool as the default documentation engine provides perhaps the most opportunity for flexibility and leanness, but also will require the most effort to develop.

> 一个自定义工具作为默认文档引擎可能提供最大的灵活性和简洁性，但也需要最大的开发努力。

A custom tool would need to either not support cross referencing to other systems or amongst itself or a cross referencing system would need to be developed, neither of which seem like a good option.

> 一个自定义工具要么不支持与其他系统或它自身之间的交叉引用，要么需要开发一个交叉引用系统，这两种都不是一个好选择。

It would be leaner than either Sphinx or Doxygen since it would have less features and would not try to document or extract code API's.

> 它比Sphinx或Doxygen都要精简，因为它拥有的功能更少，不会试图文档化或提取代码API。

### Using the Default Documentation Engine


Prioritizing for the least development time and the most features, Sphinx seems like a reasonable choice for the default documentation engine.

> 优先考虑最少的开发时间和最多的功能，Sphinx似乎是默认文档引擎的合理选择。

However, suggesting that Sphinx be the default documentation engine is not a complete proposal.

> 然而，建议Sphinx作为默认文档引擎还不是一个完整的提案。

Several details remain which will affect the requirements of the system and how the developers of packages will interact with it.

> 几个细节仍然会影响系统的要求以及开发者如何与其交互。


TODO: explain the issue with having Sphinx as the default: should the developer reuse it for documentation; should the developer run their own Sphinx instead; how to integrate them and make them both cross reference-able?

> TODO：解释使用Sphinx作为默认配置的问题：开发者是否应该重用它来进行文档；开发者是否应该自己运行Sphinx；如何将它们集成并使它们可以互相引用？


If Sphinx is the default documentation engine, one issue to sort out is whether or not the user should reuse this default run of Sphinx or not.

> 如果Sphinx是默认的文档引擎，需要解决的一个问题是用户是否应该重用这个默认的Sphinx运行。

The user could integrate their own Sphinx documentation into the default Sphinx run if the system allowed it.

> 用户如果系统允许，可以将自己的Sphinx文档集成到默认的Sphinx运行中。

On the other hand the user could put all of their Sphinx documentation into a second run of Sphinx.

> 另一方面，用户可以将他们的Sphinx文档放入第二次Sphinx运行中。


The advantage to the later option is that the fact that the default documentation is generated by Sphinx becomes an implementation detail.

> 优势在于，Sphinx生成的默认文档成为实现细节。

However, in this case there are technical details to address, like how to integrate cross referencing the default documentation run and the user's Sphinx job.

> 然而，在这种情况下，需要解决技术细节，比如如何将默认文档运行与用户的Sphinx作业进行交叉引用。

In Sphinx, a cross reference is done by calling out to another project by name.

> 在Sphinx中，可以通过按名称调用另一个项目来完成交叉引用。

For example, to reference the function `foo_func` in the `foo_pkg` package the developer would do something like this: `` ... :py:func:`foo_pkg:foo_func` ... ``.

> 例如，要在`foo_pkg`包中引用函数`foo_func`，开发人员可以这样做：`` ... :py:func:`foo_pkg:foo_func` ... ``。

When there is a single run of Sphinx per project then the name used for the mapping would simply be the package's name.

> 如果每个项目只有一次Sphinx运行，那么用于映射的名称将简单地是包的名称。

However, when there are multiple runs of Sphinx then different names would be required.

> 如果有多个Sphinx运行，则需要不同的名称。

One possibility is that the default run is always something like `<package_name>-default`, so that referencing a section in the landing page would be something like: `` ... :ref:`foo_pkg-default:SectionName` ... ``.

> 一种可能性是，默认运行总是类似 `<package_name>-default` 的东西，因此在着陆页面中引用一个部分就像这样：`` ... :ref:`foo_pkg-default:SectionName` ... ``。

It may be possible compose a single cross referencing from multiple runs of Sphinx into a single mapping to make it appear as if multiple Sphinx projects were actually one, but this would need to deal with collisions of references, something that is handled by Sphinx normally.

> 可能有可能从多次Sphinx运行中组合出一个单一的交叉引用，以使其看起来好像多个Sphinx项目实际上是一个，但这需要处理引用冲突，这是Sphinx通常处理的。

    <div class="alert alert-warning" markdown="1">
    TODO: see if merging Sphinx object-inventories is possible.
    </div>


This same issue comes up when considering if the developer should be able to run multiple instances of a particular documentation engine, for example should they be able to run Doxygen multiple times and if so, how is that organized such that other packages can cross reference both runs of Doxygen?

> 这个问题也出现在考虑开发者是否能够运行特定文档引擎的多个实例时，例如他们是否能够多次运行Doxygen，如果是这样，如何组织这样的方式，以便其他包可以跨引用两次Doxygen的运行？

## Standard Documentation Inputs and Outputs


Each documentation engine has its own inputs and outputs, so to support more than one and arbitrary documentation engines in the future, the documentation system need to have a flexible way to export and import documentation information between packages.

> 每个文档引擎都有自己的输入和输出，因此为了支持多个和任意的文档引擎，文档系统需要有一种灵活的方式来在包之间导入和导出文档信息。

All engines have some configurations which are required to do documentation.

> 所有的引擎都有一些需要做文档的配置。

For many of the configurations the default values are fine, but can be tuned to present a different behavior or look and feel.

> 对于许多配置，默认值都很好，但可以调整以呈现不同的行为或外观和感觉。

The documentation system will want to provide some default values for these configurations.

> 文档系统将为这些配置提供一些默认值。


Additionally most documentation engines have a method for configuring where to find external projects' documentation for use in cross referencing.

> 此外，大多数文档引擎都有一种配置方法，用于查找用于交叉引用的外部项目的文档。

This information is both an input and an output for documentation of packages.

> 这些信息既是文档包的输入也是输出。

The cross referencing information could be useful only for other packages using the same documentation engine or it could be useful to other packages in ways that the current package cannot not anticipate.

> 这些交叉引用信息可能只对使用相同文档引擎的其他软件包有用，或者可能以当前软件包无法预料到的方式对其他软件包有用。

For example, a C++ only package may export Doxygen XML files which is used by another package using Sphinx to do cross referencing.

> 例如，一个仅使用C++的包可以导出Doxygen XML文件，这些文件被另一个使用Sphinx的包用来做跨引用。

### Documentation Output


Because the content of this exported and imported information is specific to the documentation engines that are being used, the transfer of information should be flexible.

> 因为导出和导入的信息的内容与正在使用的文档引擎相关，所以信息的传输应该是灵活的。

One idea is that every package can generate a file which describes the sets of documentation output it generates, assigned each a name and source documentation engine.

> 一个想法是每个包可以生成一个文件，描述它生成的文档输出集，为每个赋予一个名称和源文档引擎。

For example, this might look something like this in the general form:

> 例如，这在一般形式下可能会看起来像这样：

    {% highlight yaml %}
    package_name: foo
    documentation_artifacts:
      sphinx:
        foo-default:
          output_dir: '/'
        foo:
          output_dir: '/sphinx/'
      doxygen:
        foo:
          output_dir: '/doxygen/'
          xml_output_dir: '/doxygen_xml/'
    {% endhighlight %}


This example is extremely declarative, but the developer would not need to explicitly fill this file out, but instead it could be dynamically generated by the documentation process and tooling.

> 这个例子非常声明性，但是开发人员不需要显式地填写这个文件，而是可以通过文档流程和工具动态生成。

In the above example, the output is categorized hierarchically by documentation engine, then a named run of the engine, and then the details of that run.

> 在上面的例子中，输出按文档引擎进行分类，然后是引擎的命名运行，最后是该运行的详细信息。

The details of the run can be a documentation engine specific opaque set of settings.

> .

运行的细节可以是文档引擎特定的不透明设置。

### Documentation Input


Additional information, e.g. a base path, could be paired with the above example output and given as input to another package.

> 除了上面的例子输出，可以为另一个包提供额外的信息，比如基础路径。

With a base path and this example output, other packages should be able to successfully cross reference the `foo` package if their documentation engine supports this.

> 基于基础路径和这个示例输出，如果其他软件包的文档引擎支持，应该能够成功地参考`foo`软件包。

So in addition to the default configurations, the documentation inputs for a package would be a series of base paths and "documentation artifact manifests" for each of the package's build, run, and doc dependencies.

> 除了默认配置之外，对于一个包的文档输入还包括一系列基础路径和“文档工件清单”，用于包的构建、运行和文档依赖项。

## The Documentation Job


There are two processes which need to be detailed in order to successfully document different kinds of packages.

> 有两个过程需要详细说明，以便成功记录不同类型的包。

The process with the largest scope has been described in this article as the documentation job.

> 这篇文章描述了范围最大的过程，即文档工作。

The documentation job is the process of preparing the operating system for documentation a particular package, invoking the documentation process, and then dealing with the results.

> 文档工作是准备操作系统以文档化特定包的过程，调用文档处理过程，然后处理结果。

The rough outline of the process is:

> 这个过程的大致描述是：


- Build-like dependencies are installed.

> 依赖项已安装完成。

- The package is built, unless the user opts-out.

> 包已构建，除非用户选择退出。

- Run-like and doc dependencies are installed.

> 运行依赖和文档依赖已经安装好了。

- The package is documented using the documentation process.

> 包使用文档过程进行了文档化。

- The documentation which has been installed is packaged or moved to hosting.

> 文档已安装，已打包或移动到托管服务器上。

    <div class="alert alert-warning" markdown="1">
    TODO: Fill in details about the documentation job
    </div>


## The Documentation Process


The documentation process consists of the series of actions which must be preformed in order to generate documentation for a single package.

> 文档过程包括一系列必须为单个包生成文档而执行的动作。

The process starts with an environment that has all of the dependencies for the package resolved and in which the package has already been built.

> 这个过程从一个已经解决了所有包依赖并且已经构建好的环境开始。

This process constitutes what happens for the "doc target" of the build tools.

> 这个过程构成了构建工具“doc target”发生的事情。

The build tools will perform these steps in the documentation process:

> 编译工具将在文档流程中执行以下步骤:


- Create a list of requested and implicit runs of documentation engines.

> 列出所需和隐式运行文档引擎的列表。

- For each run, the appropriate default configurations and inputs are compiled.

> 每次运行，都会编译适当的默认配置和输入。

- For each run, documentation engine specific execution occurs.

> 每次运行，都会发生文档引擎特定的执行。

- For each run, the generated documentation output is cataloged and copied to the install destination.

> 每次运行，生成的文档输出都会被归档并复制到安装目标位置。

- The cataloged output meta data is compiled into a single documentation manifest for the package and installed.

> 编目输出元数据被编译成一个文档清单，用于安装该包。


The implicit runs would encompass the default documentation engine.

> .

隐式运行将包括默认的文档引擎。

    <div class="alert alert-warning" markdown="1">
    TODO: Fill in details about the documentation process
    </div>

## User Stories


This section will look at the documentation system from the point of view of the users, in this case package developers and package consumers, by constructing some common and uncommon scenarios in order to gain a better understanding of the requirements.

> 这一节将从用户的角度来看文档系统，在这种情况下是包开发者和包消费者，通过构建一些常见和不常见的场景，以便更好地了解需求。

### Discovering Packages Through Documentation


Scenario:

> 情景：


A "package consumer", someone who is looking for packages to use in their ROS system, hears about a package that sounds interesting to them, e.g. `wall_e_plant_detection`.

> 一个"包消费者"，他们正在寻找可以在自己的ROS系统中使用的包，听说了一个听起来很有趣的包，例如`wall_e_plant_detection`。

She searches for `wall_e_plant_detection` with her favorite search engine and finds a page which summarizes or references the package.

> 她用她最喜歡的搜索引擎搜索`wall_e_plant_detection`，找到了一個總結或引用該包的頁面。

After a while she realizes that she can go to `packages.ros2.org/wall_e_plant_detection` get redirected to the latest version of the package for the current ROS distribution, which might end up going to something more specific like `http://packages.ros2.org/en/jade/latest/wall_e_plant_detection/index.html`.

> 沒一會，她意識到她可以去packages.ros2.org/wall_e_plant_detection重定向到當前ROS發行版的該包的最新版本，最終可能會去到更具體的位置，如http://packages.ros2.org/en/jade/latest/wall_e_plant_detection/index.html。

The page summarizes or references all the information about the package that can be compiled by the documentation system, e.g. Code documentation, Tutorials, wiki, jobs on the farm, etc.

> 这个页面总结或引用了可以由文档系统编译的包的所有信息，例如代码文档、教程、维基、农场工作等。

This page has also been customized by the developer to include a longer description and more content like custom links to external resources.

> 这个页面也已经被开发人员定制，包括更长的描述和更多内容，如到外部资源的自定义链接。


This ROS package landing page would be similar to the landing pages for Ubuntu packages, e.g. `http://packages.ubuntu.com/trusty/libboost-all-dev`.

> 这个ROS软件包的登陆页面将类似于Ubuntu软件包的登陆页面，例如`http://packages.ubuntu.com/trusty/libboost-all-dev`。

From here the user can discover general and API documentation, tutorials, other versions, dependencies, dependents, provided resources, etc., all for this package.

> 从这里，用户可以发现这个包的常规文档、API文档、教程、其他版本、依赖项、依赖项、提供的资源等等。

`packages.ros2.org` is just an example.

Based on the implementation of the infrastructure for this site, something more like `docs.ros2.org` may make more sense.

> 根据这个网站的基础设施实施情况，更像`docs.ros2.org`的形式可能更有意义。

Even `wiki.ros2.org`, if it is implemented more as a wiki with static pages embedded throughout.

> 即使是`wiki.ros2.org`，如果它被更多地实现为一个具有嵌入静态页面的wiki，也是如此。


One question is whether or not the package developer should be able to customize this page at all.

> 一个问题是包开发者是否应该能够自定义这个页面。

Ideally the developer could hook into this process and add more stuff than what is in the `package.xml`'s description.

> 理想情况下，开发人员可以接入此过程，并添加比`package.xml`描述中更多的东西。

This could be accomplished by either having the ability to import something like a `README.rst` file or the ability for the developer to edit the contents of the landing page directly as a file in their repository.

> 这可以通过有能力导入类似`README.rst`文件的能力，或者开发者直接将着陆页面的内容作为他们仓库中的文件进行编辑的能力来实现。

### Documentation for a Released Package


Scenario:

> 场景：


After providing zero extra documentation or configuration a package developer releases their package to take advantage of the binary packaging provided for released packages.

> 没有提供额外的文档或配置，软件包开发者发布软件包，以利用发布的软件包提供的二进制打包。

After the release has been processed by the build farm, the package will have a discoverable landing page with as much information extracted from the package as is possible.

> 经过构建农场处理发布之后，该包将拥有一个可发现的着陆页面，其中包含尽可能多从包中提取的信息。


This is a slight improvement on the ROS 1 system, because in ROS 1 the package developer would have to additionally go to the wiki and create a package with the `PackageHeader` macro in it in order to gain the same effect.

> 这是对ROS 1系统的一个轻微改进，因为在ROS 1中，包开发人员必须额外转到Wiki上，使用`PackageHeader`宏创建一个包，才能获得同样的效果。

### Documentation for an Unreleased Package


Scenario:

> 情景：


A package developer would like to make their package discoverable by others and have their documentation hosted, but has not taken the time to do a proper release of the package.

> 一个软件包开发者想让别人发现他们的软件包，并将文档托管，但他们没有花时间做一个正式的软件包发布。

She submits a pull request to the ROS distribution file to add a "doc" entry for her package(s).

> 她向ROS发行文件提交了一个拉取请求，以为她的包添加一个"doc"条目。

This doc entry points to repository which contains her package(s) on her main development branch.

> 这个文档条目指向一个存储库，其中包含她的主要开发分支上的软件包。

Later the build farm, triggered either by a commit or a periodic timer, cloned her repository and ran the documentation job on the package(s).

> 后来，建筑农场，无论是通过提交还是定期定时器触发，克隆了她的存储库并在包上运行了文档作业。

Documentation was generated based on her package's configurations and the result is uploaded to the doc servers for others to find.

> 文档是根据她的软件包的配置生成的，结果已上传到文档服务器，供其他人查找。


The scenario shows that users should be able to take advantage of as much of the documentation system as possible without releasing their package.

> 用户应该尽可能多地利用文档系统，而不需要发布他们的包。

### Maintaining Multiple Versions of Documentation


Scenario:

> 情景：


A package developer adds to the public API in a backwards compatible way during a ROS release, e.g. between versions `1.1.0` and `1.2.0` for the Jade ROS distribution.

> 一个软件包开发者在ROS发布期间以向后兼容的方式向公共API添加内容，例如Jade ROS发行版本1.1.0和1.2.0之间。

Because of this change, the package developer would like to make the documentation for both versions of the package available to their users.

> 因此，软件包开发者希望为其用户提供两个版本的文档。

So in addition to specifying a branch of their VCS repository that should be documented periodically using a doc entry, she explicitly specifies version `0.1.0` to be generated and kept around.

> 她还特别指定要生成并保留版本“0.1.0”，以定期使用文档条目记录其版本控制系统仓库的分支。

So now there are three versions of the documentation for Jade, her latest branch `jade-devel`, version `0.1.0`, and the most recent released version `0.2.0`.

> 现在有三个版本的Jade文档，她最新的分支“jade-devel”，版本“0.1.0”，以及最新发布的版本“0.2.0”。

When users browse to her package's documentation they will see three options for versions of documentation for Jade, `latest`, `0.1.0`, and `0.2.0`.

> 当用户浏览她的软件包的文档时，他们会看到Jade的三个文档版本，即`最新版`，`0.1.0`和`0.2.0`。


Currently the ROS 1 infrastructure only allows for one version of documentation per package per ROS distribution.

> 目前ROS 1基础设施只允许每个ROS发行版中每个软件包有一个版本的文档。

This works for most cases, but a more flexible option for packages which change during the life time of distributions would be to have multiple released versions as well as a floating "latest" version if desired.

> 这通常适用，但是对于在发行版本的生命周期中变化的软件包来说，更灵活的选项是发布多个版本，如果需要的话，还可以有一个浮动的“最新”版本。

To do this would require capturing which VCS tags should be documented, where the tags map to older versions of the software.

> 这需要捕获哪些VCS标签应该被记录，这些标签映射到软件的旧版本。

This would be in addition to the information we already capture in the "doc" entry which covers a tag or branch to document and the "release" entry which tells us the latest version of the package currently released but not previous versions.

> 这将是除了我们已经在“doc”条目中捕获的信息之外，该条目用于记录标签或分支以及“release”条目，该条目告诉我们当前发布的软件包的最新版本，但不包括以前的版本。

This idea is borrowed from the way the [https://readthedocs.org/](https://readthedocs.org/) on-line documentation service operates.

> 这个想法是从[https://readthedocs.org/](https://readthedocs.org/)在线文档服务的运作方式中借鉴而来的。

## Documentation Requirements


The functional requirements were arrived at by building on the experience of the ROS 1 documentation system and practices, while keeping in mind some non-functional requirements.

> 功能要求是通过建立在ROS 1文档系统和实践的经验基础上，同时考虑一些非功能性要求而得出的。

### Non-Functional Requirements


Listed in no particular order, the documentation system should be...

> 没有特定顺序，文档系统应该是...


- _scalable_ by ensuring that a default, minimal output for each package is generated with zero configuration.

> 确保每个包都能够通过零配置生成默认最小输出，从而实现可伸缩性。

- _usable_ by reusing information in the package manifest to minimize duplication of information throughout.

> 可以通过重用包清单中的信息来最大限度地减少信息的重复。

- _extensible_ by ensuring that many documentation engines can be supported and that special elements can be automatically documented, e.g. ROS messages, launch files, node parameters, etc.

> 确保可以支持许多文档引擎，并且可以自动文档化特殊元素（例如ROS消息、启动文件、节点参数等），以实现可扩展性。

- _standard compliant and conventional_ by reusing tools which already exist where possible.

> 尽可能重用现有工具，符合标准和常规。

- _accessible and consistent_ by providing common configuration items in order to reduce effort for developers and to improve consistency across packages.

> 提供常见的配置项目以减少开发人员的工作量，并改善各个包之间的一致性，以实现可访问性和一致性。

- _configurable_ by giving the developer access to each documentation engine's configuration, as not to hinder their ability to customize the output.

> 通过给开发者访问每个文档引擎的配置，不妨碍他们自定义输出的能力，使其可配置。

- _maintainable_ by reusing specific documentation engine's configuration mechanism where possible.

> 尽可能地利用特定文档引擎的配置机制来保持可维护性。

- _efficient_ by allowing the developer to opt-out of steps which are not required for their package.

> 允许开发者选择不需要为他们的包执行的步骤，从而实现高效。

- _safe_ by identifying undesirable results and notifying the developer.

> 通过识别不良结果并通知开发人员来确保安全。

- _discoverable_ by having easy to read and understand URL schemes and by facilitating the storage of and switching between multiple versions of the documentation.

> 可发现，通过具有易于阅读和理解的URL架构，以及促进存储和在多个版本之间切换文档。

- _stable_ by having conventions about documentation layout, warning when they are violated, and enforcing them where possible.

> 保持文档布局的约定，当它们被违反时发出警告，并尽可能地执行它们，以保持稳定。


These no-functional requirements, or qualities, of the system guided the following proposed functional requirements and system design.

> 这些非功能性需求或质量指导了下面提出的功能性需求和系统设计。

### Functional Requirements


The above non-function requirements have suggestions at some of the more concrete function requirements.

> .

以上的非功能需求在一些更具体的功能需求中有建议。

Listed in no particular order, the documentation system will...

> 按无特定顺序列出，文档系统将...


- support at least Sphinx and Doxygen.

> 至少支持 Sphinx 和 Doxygen。

- document each package, one at a time, in a topological order which respects `<doc_depend>` type dependencies.

> 按照`<doc_depend>`类型依赖的拓扑顺序，逐个文档化每个包。

- build each package before running documentation engines.

> 在运行文档引擎之前，先构建每个包。

- allow developers to skip building their package before running documentation engines on it.

> 允许开发人员在运行文档引擎之前跳过构建他们的包。

- run Sphinx by default.

> 默认运行Sphinx。

- **_not_** allow the developer to skip running Sphinx on their package.

> 不允许开发者跳过在它们的包上运行Sphinx

- provide a default Sphinx configuration for packages which do not provide one.

> 为不提供默认Sphinx配置的包提供默认Sphinx配置。

- provide a tool to generate the default Sphinx configuration, allowing the developer to modify it.

> 提供一个工具来生成默认的Sphinx配置，以便开发者可以修改它。

- validate the Sphinx settings and warn the developer in the case that a setting might cause a problem with the output.

> 验证Sphinx设置，如果设置可能导致输出问题，则警告开发人员。

- provide a mechanism in Sphinx to access and reuse information stored in the package manifest file.

> 提供一种机制，以便在Sphinx中访问和重用存储在包清单文件中的信息。

- provide a mechanism in Sphinx to generate the "package page header" which summarizes the package and provides a consistent landing page for all packages (similar to the package header in the ROS 1 wiki).

> 提供一种机制，在Sphinx中生成“包页面头”，该头部概括包的内容，并为所有包提供一致的入口页面（类似于ROS 1维基中的包头）。

- enforce that the index page for Sphinx follows a certain format which starts with the "package page header".

> 强制要求Sphinx的索引页面遵循一个特定的格式，以"包页面头"开头。

- enforce that reserved names are not used as pages or folders in the Sphinx layout, e.g. `msgs` which will contain ROS message documentation.

> 强制要求不能在Sphinx布局中使用保留的名称作为页面或文件夹，例如`msgs`将包含ROS消息文档。

- run Doxygen by default.

> 默认情况下运行Doxygen。

- allow the developer to skip running Doxygen on their package.

> 允许开发人员跳过在他们的包上运行Doxygen。

- provide default Doxygen configuration for packages which do not provide them.

> 为没有提供默认Doxygen配置的包提供默认Doxygen配置。

- provide a tool to generate the default Doxygen configuration, allowing the developer to modify them.

> 提供一个工具来生成默认的Doxygen配置，以便开发者可以对其进行修改。
