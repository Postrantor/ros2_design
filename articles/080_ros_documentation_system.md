---
tip: translate by openai@2023-05-30 22:41:54
layout: default
title: ROS 2 Documentation System
permalink: articles/ros_documentation_system.html
abstract:
  This article describes the proposed system for doing documentation for ROS 2.
author: '[William Woodall](https://github.com/wjwwood)'
date_written: 2015-01
last_modified: 2016-02
published: false
Authors: {{ page.author }}
Date Written: {{ page.date_written }}
Last Modified: {% if page.last_modified %}{{ page.last_modified }}{% else %}{{ page.date_written }}{% endif %}
---
This document is meant to capture the results of discussions about the way we (the ROS 2 developers) would like documentation to work in ROS 2 and polish those results into a proposal. It is likely that this document should be refined and made into a REP once a suitable design is settled on.

> 这份文件旨在捕捉我们（ROS 2 开发者）希望在 ROS 2 中文档工作的方式以及将结果改进为提案的讨论结果。一旦设计确定，这份文件很可能需要细化并转化为 REP。

## Glossary

- **Documentation Engine**: Any tool which takes in information and produces documentation for the end user, e.g. Sphinx, Doxygen, a custom documentation script, etc.
- **Documentation Job**: A series of actions taken to provide documentation prerequisites, do documentation, validate the result, and finally transfer the result to a hosting solution, i.e. what to do on the build farm.
- **Documentation Process**: A well defined process by which any package can be introspected and then have all of its documentation generated by running the correct documentation engines with the correct settings, i.e. how to build documentation for any package.
- **Documentation System**: The cumulation of all components of documentation including: describing what to document, the documentation job, the documentation process, the documentation inputs and outputs for every package, and supporting tools.

## Documentation System Overview

Probably the principal difference between this proposed design and the existing ROS 1 system is the belief that general documentation about a package should be captured in the package as version controlled plain text files.

> 可能这个拟议的设计与现有的 ROS 1 系统的主要区别在于，认为关于一个包的一般文档应该作为版本控制的纯文本文件捕获在包中。

### Wiki Versus Static Documentation

In this case "general" documentation is what you would typically find on the ROS 1 wiki and consists of things like detailed descriptions of packages, links to external references, images and diagrams, descriptions of nodes, launch files, and other common components of ROS packages. This is to distinguish these things from other kinds of documentation like Code API documentation, which is often written along side the code as comments, extracted automatically, and so therefore traditionally kept in plain text formats and version controlled with the code already. This "general" documentation could also encompass other types of documentation or memorandum like tutorials, API reviews, and discussions, but these types of documentation could also be kept in a separate system like a wiki.

> 在这种情况下，“一般”文档指的是您通常可以在 ROS 1 wiki 上找到的内容，例如详细的软件包描述、外部参考链接、图像和图表、节点描述、启动文件和其他 ROS 软件包的常见组件。这是为了区分这些东西与其他类型的文档，如代码 API 文档，这些文档通常作为注释写在代码中，自动提取，因此通常保存在纯文本格式中，并与代码一起进行版本控制。这种“一般”文档也可以包含其他类型的文档或备忘录，如教程、API 评论和讨论，但这些类型的文档也可以保存在另一个系统中，如 wiki。

In ROS 1, a conscious decision was made to push as much of the documentation into the ROS 1 wiki as possible and in ROS 2 we would like to diverge from that and suggest that more documentation should be version controlled with the code. The main reason, as far as we can gather, for this decision in ROS 1 was to make it as easy as possible for non developers to contribute changes to the documentation. It is still the case for outsiders that changing documentation in a source repository is more difficult than documentation which is located in a wiki. However, it seems that times have changed in this respect, and that the gap between editing a wiki page and getting a change in a source repository has narrowed. This is mostly due to improvements in the open source contribution practices on services like GitHub and BitBucket and the proliferation of both the Pull Request pattern and the "Edit in GitHub/BitBucket" buttons on generated documentation pages.

> 在 ROS 1 中，我们有意识地决定将尽可能多的文档推送到 ROS 1 维基上，而在 ROS 2 中，我们希望从中偏离，建议更多的文档应该随着代码进行版本控制。据我们所知，这个决定在 ROS 1 中的主要原因是为了让非开发人员尽可能容易地对文档进行更改。对外部人员来说，在源存储库中更改文档仍然比位于维基中的文档更加困难。但是，似乎情况已经发生了变化，在 GitHub 和 BitBucket 等开源服务上改进了贡献实践，并且拉取请求模式和“在 GitHub/BitBucket 中编辑”按钮在生成的文档页面上普及，编辑维基页面和在源存储库中获得更改之间的差距已经缩小。

In exchange for moving some types of documentation into the source repository, we believe that maintaining changes in documentation across different ROS versions and different package versions will become easier. Additionally, the systems for doing code documentation will allow for more robust cross referencing to and from the code API documentation. Finally, by doing this kind of documentation in code, it brings the ROS community's recommended practices closer to common practice for modern open source software projects, where the last few years have seen a migration from wiki's to statically generated documentation which comes from plain text files in the version control system.

> 为了将一些文档类型移植到源代码仓库，我们相信维护不同 ROS 版本和不同软件包版本中的文档变化将变得更加容易。此外，用于进行代码文档的系统将允许更强大的跨引用和代码 API 文档。最后，通过这种代码文档的方式，它将 ROS 社区推荐的实践更接近现代开源软件项目的常规实践，在过去的几年中，我们已经从 wiki 迁移到静态生成的文档，这些文档来自版本控制系统中的纯文本文件。

### Risks of Static Documentation

There are some risks associated with using static documentation over something more dynamic like a wiki. As mentioned before the barrier to entry to contributions may be too high for some users, especially on documentation which does not need review for each change. Another potential issue is in documenting packages which would like to straddle multiple ROS distributions. This happens with code too, where a package would ideally have one line of versions and one development branch for several similar ROS distributions. Doing so cuts down on the number branches and amount of forward and back porting required which reduces the overall developer load. By doing more documentation in source it may become harder to maintain these ROS agnostic development branches. This essentially becomes a trade-off in how easy it is to document packages with large or small changes between ROS distributions.

> 使用静态文档而不是像 wiki 这样更动态的东西会有一些风险。正如之前提到的，对于一些用户来说，参与贡献的门槛可能太高，特别是对于不需要每次更改都进行审查的文档。另一个潜在的问题是，在文档中记录希望跨多个 ROS 发行版的软件包。这也发生在代码上，一个软件包理想情况下会有一条版本线和一个开发分支用于多个类似的 ROS 发行版。这样可以减少分支的数量和前后移植所需的工作量，从而减轻开发者的工作负担。通过在源代码中做更多的文档，可能会变得更难维护这些 ROS 万能的开发分支。这本质上成为了一种权衡，即在 ROS 发行版之间有大量变化的软件包文档化有多容易。

Another risk of this proposal is that it may discourage usage of a wiki in scenarios where a wiki would be appropriate. The intention of this proposal is not to suggest that wiki's should not be used, but instead means it will be up to the developer to decide what kinds of documentation are best suited for difference documentation options. For example, documentation which bridges multiple packages is not well suited to being contained in one package's documentation and therefore may work better in a wiki style system. However, by encouraging developers to make use of static documentation generation tools, there will be less need for heavy infrastructure, mirroring the documentation will be easier, and documentation will be more tightly coupled to the code.

> 这个提案的另一个风险是，它可能会降低在适当的情况下使用 wiki 的使用率。这个提案的目的不是建议不要使用 wiki，而是让开发者决定哪种文档最适合不同的文档选项。例如，跨多个包的文档不适合放在一个包的文档中，因此可能更适合使用 wiki 风格的系统。但是，通过鼓励开发人员使用静态文档生成工具，将会减少对重型基础架构的需求，文档的镜像将会更容易，文档将更紧密地与代码相关联。

### Other Goals of the Documentation System

One desired goal of the documentation system is to generate a standard landing page for all packages which are released or documented. Similar to how the [PackageHeader](http://wiki.ros.org/WikiMacros#PackageHeader) wiki macro works in ROS 1, this page would summarize the items common to all packages. These items would consist of information extracted from the package manifest, the package's README file, and other external resources like the build farm and the ROS distribution file. This page can also contain dynamically generated information about the package which transcends one version of the package or one ROS distribution, e.g. it could list all of the ROS distributions in which the package has been released. This page would also be able to automatically collect and link to resources in the packages. For example, it could link to documentation for messages or external services like wiki's and other kinds of external documentation. Ideally this page would be easy to produce locally as part of the normal documentation of the package and is not something special that is only done on the ROS infrastructure. Generating it locally would allow the developer to preview all of the content for their package before publishing it to the publicly hosted infrastructure. To support this goal, there would need to be a documentation engine which is run by every ROS package regardless of any other general documentation a developer wishes to create.

> 系统文档的一个期望目标是为所有发布或文档化的包生成一个标准的入口页面。类似于 ROS 1 中的 [PackageHeader](http://wiki.ros.org/WikiMacros#PackageHeader) wiki 宏，这个页面将汇总所有包的共同项目。这些项目将包括从包清单、包的 README 文件和其他外部资源（如构建农场和 ROS 发行文件）中提取的信息。此页面还可以自动收集和链接包中的资源。例如，它可以链接到消息或外部服务（如 wiki 和其他类型的外部文档）的文档。理想情况下，在发布到公开托管的基础架构之前，开发人员可以在本地轻松生成此页面，而不是做一些特殊的事情。本地生成将允许开发人员预览他们的包中的所有内容。为了支持这个目标，每个 ROS 包都需要运行一个文档引擎，而不管开发人员希望创建任何其他一般文档。

Another goal of the system is to support general documentation of ROS packages in source repositories rather than in a separately version controlled system like a wiki. To achieve this the system would need to supply the developers with ROS specific documentation tools. These kinds of tools would do things like cross reference to ROS messages automatically or make the information from the package manifest accessible in the documentation engine. This kind of tooling would need to be provided for each documentation engine which we expect users to use for general documentation, which would be a burden to support. Therefore, it would make sense to have a recommended documentation engine for general documentation of packages, limiting the need for tools in many documentation engines.

> 系统的另一个目标是支持 ROS 包在源代码仓库中的一般文档，而不是在像 wiki 这样的独立版本控制系统中。为了实现这一点，系统需要为开发人员提供 ROS 特定的文档工具。这些工具可以自动实现 ROS 消息的交叉引用，或者使来自包清单的信息在文档引擎中可用。这种工具需要为每个文档引擎提供，我们期望用户使用这些文档引擎进行一般文档，这将是一个负担来支持。因此，最好有一个推荐的文档引擎来进行包的一般文档，以减少许多文档引擎的工具需求。

There are some other tasks which every package _may_ need to perform based on its contents. Typically this is related to documenting special parts of the package, things like messages, launch files, or node parameter descriptions. For messages (include services and actions), no extra action may be necessary since there is a build time generation step at which point documentation could also be generated. However, there is no such step in the normal build process where generating documentation for things launch files is appropriate so packages which contain these things will need to generate documentation using some documentation engine, regardless of any other general documentation the developer creates. Even if the developer does not reference their own launch files or messages, another package may wish to, so the documentation for these things should always be created.

> 有些其他任务可能根据其内容需要执行，通常与文档化包的特殊部分有关，比如消息、启动文件或节点参数描述。对于消息（包括服务和操作），可能不需要额外的操作，因为有一个构建时间生成步骤，在这一点上可以生成文档。但是，在正常构建过程中没有这样的步骤，可以使用某种文档引擎生成启动文件的文档，所以包含这些东西的包将需要生成文档，而不管开发人员创建了什么其他一般文档。即使开发人员不引用自己的启动文件或消息，另一个包也可能希望这样做，因此这些文档应该始终创建。

## Default Documentation Engine

Based on the above goals, it seems clear that one or more default documentation engines will be required. The above goals mostly apply to ROS packages, but not necessarily any package our tool chain can build, i.e. third party CMake, Python, or autotools packages. The distinction is that our tool chain should not automatically assume a default engine, but rather the qualities that make a package a "ROS" package, i.e. depending on a ROS documentation package, should determine whether or not the default documentation engine is exercised by the tool chain. This allows the tool chain to be agnostic to these additional items which are common to all ROS packages, but not necessarily all packages.

> 根据上述目标，似乎很明显需要一个或多个默认文档引擎。上述目标主要适用于 ROS 包，但不一定适用于我们的工具链可以构建的任何包，即第三方 CMake，Python 或 autotools 包。区别在于，我们的工具链不应该自动假定默认引擎，而应该是使一个包成为“ROS”包的品质，即依赖于 ROS 文档包，来确定工具链是否执行默认文档引擎。这允许工具链不受这些所有 ROS 包都具有但不一定所有包都具有的其他项目的影响。

While it would be convenient to have one default documentation engine, it may be necessary to have several for either technical reasons or for modularity. For simplicity, this article will describe a system with a single documentation system, with the understanding that this default documentation engine may have inputs from previous processes or that it might aggregate several different tools as part of its execution.

> 虽然有一个默认的文档引擎会很方便，但出于技术原因或模块化的需要，可能需要多个文档引擎。为了简单起见，本文将描述一个只有一个文档系统的系统，但要理解这个默认文档引擎可能会从先前的过程中获得输入，或者它可能会在执行过程中聚合多个不同的工具。

So for ROS packages this default engine would always be run and would be responsible for generating the package's landing page and for generating documentation for any special items like launch files and other common items which can be automatically documented. If the developer does not provide any configurations for this default documentation engine then a boiler plate configuration which generates a landing page would be created for them automatically. This would allow all packages to have some minimal documentation with zero configuration by the developer. The developer would be able to generate this boiler plate documentation and configuration if they wanted to modify it, for instance to add something to the default landing page (much like you would on the ROS 1 wiki below the PackageHeader macro). However, the system should do some minimal check to ensure that the landing page looks and feels consistent with other packages, e.g. ensure the equivalent to the "PackageHeader" is on the landing page and that the ROS theme is being used or extended.

> 对于 ROS 包，这个默认引擎将始终被运行，负责生成包的落地页面，并为任何特殊项目（如启动文件和其他可自动文档化的常见项目）生成文档。如果开发人员没有提供任何此默认文档引擎的配置，则会自动为他们创建一个生成落地页面的锅炉板配置。这将使所有包都能够零配置地具有一些最低限度的文档。如果开发人员想要修改它，例如向默认落地页面添加某些内容（就像在 ROS 1 wiki 下的 PackageHeader 宏一样），则开发人员可以生成此锅炉板文档和配置。但是，该系统应该做一些最小的检查，以确保落地页面的外观和感觉与其他包一致，例如确保等效于“PackageHeader”的内容出现在落地页面上，并且使用或扩展了 ROS 主题。

When selecting a default engine, some things should be considered:

> 在选择默认引擎时，应该考虑一些事情：

- The engine should be easy to extend (in order to provide the aforementioned tooling to the developer).
- The engine's syntax should be easy to learn (on the level of the current ROS 1 wiki's syntax).
- The engine must be design for general purpose documenting (not just automatic code documenting).
- The engine should have a cross referencing system to help maintain links between packages.

Based on that, feasible options would include Sphinx, Doxygen, or a custom Python script that just expands an `empy` template.

> 根据此，可行的选项包括 Sphinx、Doxygen 或只是扩展 `empy` 模板的自定义 Python 脚本。

### Sphinx as a Default Documentation Engine

Sphinx is a compelling solution since it can be easily extended with Python and has a cross referencing system. It uses the ReStructured Text (rst) standard for its markup language, which is fairly easy to learn, but can be cumbersome in some scenarios. The benefit of rst and Sphinx is that its "directive" system provides a flexible way to extend the markup language without relying on an external template system. Philosophically, Sphinx is oriented around creating documentation rather than extracting documentation from code.

> Sphinx 是一个引人注目的解决方案，因为它可以用 Python 轻松扩展，并具有交叉引用系统。它使用 ReStructured Text（rst）标准作为其标记语言，这是相当容易学习的，但在某些情况下可能会很麻烦。 rst 和 Sphinx 的好处是，它的“指令”系统提供了一种灵活的方式来扩展标记语言，而不依赖于外部模板系统。在哲学上，Sphinx 的定位是创建文档而不是从代码中提取文档。

### Doxygen as a Default Documentation Engine

Doxygen would also be a good choice since it has a good cross reference system and can parse markdown files for general purpose documentation. Markdown is arguably simpler and easier to read than rst, but it also is less flexible since it does not have a built in system for extension. Doxygen has manually extended Markdown to include cross referencing, but more complicated tasks would need to be done using a template engine in conjunction with Markdown, similar to how Jekyll works. Doxygen excels at extracting documentation from code, especially C++ and Java, and has a lot of its features geared toward describing and automatically organizing code documentation. Its extension system is arguably less approachable than Sphinx's since they are done in C++ and scripting of Doxygen commands is limited to argument aliasing.

> Doxygen 也是一个很好的选择，因为它有一个很好的交叉引用系统，可以解析用于通用文档的 Markdown 文件。与 rst 相比，Markdown 可能更简单、更容易阅读，但它也不够灵活，因为它没有内置的扩展系统。Doxygen 已经手动扩展了 Markdown，以包括交叉引用，但更复杂的任务需要使用模板引擎与 Markdown 结合，类似于 Jekyll 的工作方式。Doxygen 在从代码（特别是 C++ 和 Java）中提取文档方面做得很好，并且有很多功能是专门用于描述和自动组织代码文档的。与 Sphinx 的扩展系统相比，它的扩展系统可能不太容易接近，因为它们是用 C++ 实现的，而对 Doxygen 命令的脚本化仅限于参数别名。

### Custom Tool as a Default Documentation Engine

A custom tool as the default documentation engine provides perhaps the most opportunity for flexibility and leanness, but also will require the most effort to develop. A custom tool would need to either not support cross referencing to other systems or amongst itself or a cross referencing system would need to be developed, neither of which seem like a good option. It would be leaner than either Sphinx or Doxygen since it would have less features and would not try to document or extract code API's.

> 自定义工具作为默认文档引擎可能提供最大的灵活性和精简性，但也需要最大的开发努力。自定义工具要么不支持与其他系统或自身之间的交叉引用，要么需要开发一个交叉引用系统，这两个选择都不是好选择。它比 Sphinx 或 Doxygen 都要精简，因为它具有更少的功能，不会尝试文档化或提取代码 API。

### Using the Default Documentation Engine

Prioritizing for the least development time and the most features, Sphinx seems like a reasonable choice for the default documentation engine. However, suggesting that Sphinx be the default documentation engine is not a complete proposal. Several details remain which will affect the requirements of the system and how the developers of packages will interact with it.

> 优先考虑最少的开发时间和最多的功能，Sphinx 似乎是默认文档引擎的合理选择。但是，建议将 Sphinx 作为默认文档引擎还不是一个完整的提案。将会影响系统的要求以及包开发者如何与其交互的几个细节仍然存在。

TODO: explain the issue with having Sphinx as the default: should the developer reuse it for documentation; should the developer run their own Sphinx instead; how to integrate them and make them both cross reference-able?

> TODO：解释 Sphinx 作为默认情况下的问题：开发者是否应该重用它来进行文档编写；开发者是否应该运行自己的 Sphinx；如何集成它们，使它们可以互相引用？

If Sphinx is the default documentation engine, one issue to sort out is whether or not the user should reuse this default run of Sphinx or not. The user could integrate their own Sphinx documentation into the default Sphinx run if the system allowed it. On the other hand the user could put all of their Sphinx documentation into a second run of Sphinx.

> 如果 Sphinx 是默认的文档引擎，需要解决的一个问题是用户是否应该重用这个默认的 Sphinx 运行。如果系统允许的话，用户可以将他们自己的 Sphinx 文档集成到默认的 Sphinx 运行中。另一方面，用户可以将所有的 Sphinx 文档放到第二个 Sphinx 运行中。

The advantage to the later option is that the fact that the default documentation is generated by Sphinx becomes an implementation detail. However, in this case there are technical details to address, like how to integrate cross referencing the default documentation run and the user's Sphinx job. In Sphinx, a cross reference is done by calling out to another project by name. For example, to reference the function `foo_func` in the `foo_pkg` package the developer would do something like this: ``... :py:func:`foo_pkg:foo_func` ...``. When there is a single run of Sphinx per project then the name used for the mapping would simply be the package's name. However, when there are multiple runs of Sphinx then different names would be required. One possibility is that the default run is always something like `<package_name>-default`, so that referencing a section in the landing page would be something like: ``... :ref:`foo_pkg-default:SectionName` ...``. It may be possible compose a single cross referencing from multiple runs of Sphinx into a single mapping to make it appear as if multiple Sphinx projects were actually one, but this would need to deal with collisions of references, something that is handled by Sphinx normally.

> 后一个选项的优势是，默认文档由 Sphinx 生成变成了一个实现细节。但是，在这种情况下，还有技术细节需要解决，比如如何将默认文档运行和用户的 Sphinx 工作集成在一起。在 Sphinx 中，可以通过按名称调用另一个项目来实现交叉引用。例如，要引用 `foo_pkg` 包中的函数 `foo_func`，开发人员可以这样做：``...:py:func：`foo_pkg:foo_func`...``。如果只有一次 Sphinx 运行，那么用于映射的名称就是包的名称。但是，如果有多次 Sphinx 运行，则需要不同的名称。一种可能性是，默认运行总是像 `<package_name>-default` 这样的东西，这样引用着页面中的一节就会是这样：``...:ref:`foo_pkg-default:SectionName`...``。可能可以将多次 Sphinx 运行的单个交叉引用组合成一个映射，使其看起来好像多个 Sphinx 项目实际上只有一个，但是这需要处理引用冲突，这是 Sphinx 通常处理的。

<div class="alert alert-warning" markdown="1">
    TODO: see if merging Sphinx object-inventories is possible.
</div>

This same issue comes up when considering if the developer should be able to run multiple instances of a particular documentation engine, for example should they be able to run Doxygen multiple times and if so, how is that organized such that other packages can cross reference both runs of Doxygen?

> 这个问题也出现在考虑开发者是否能够运行特定文档引擎的多个实例时，例如他们是否能够多次运行 Doxygen，如果是这样，该如何组织以便其他软件包能够跨参考这两次运行的 Doxygen？

## Standard Documentation Inputs and Outputs

Each documentation engine has its own inputs and outputs, so to support more than one and arbitrary documentation engines in the future, the documentation system need to have a flexible way to export and import documentation information between packages. All engines have some configurations which are required to do documentation. For many of the configurations the default values are fine, but can be tuned to present a different behavior or look and feel. The documentation system will want to provide some default values for these configurations.

> 每个文档引擎都有自己的输入和输出，因此为了在未来支持多个任意文档引擎，文档系统需要有一种灵活的方式来在包之间导入导出文档信息。所有引擎都有一些配置，这些配置是必须做文档的。对于许多配置，默认值就可以了，但可以调整以呈现不同的行为或外观。文档系统将为这些配置提供一些默认值。

Additionally most documentation engines have a method for configuring where to find external projects' documentation for use in cross referencing. This information is both an input and an output for documentation of packages. The cross referencing information could be useful only for other packages using the same documentation engine or it could be useful to other packages in ways that the current package cannot not anticipate. For example, a C++ only package may export Doxygen XML files which is used by another package using Sphinx to do cross referencing.

> 此外，大多数文档引擎都有一种配置用于查找外部项目文档以用于交叉引用的方法。此信息既是包文档的输入也是输出。交叉引用信息可能仅对使用相同文档引擎的其他包有用，也可能以当前包无法预料的方式对其他包有用。例如，仅使用 C++ 的包可以导出 Doxygen XML 文件，该文件被使用 Sphinx 的另一个包用于交叉引用。

### Documentation Output

Because the content of this exported and imported information is specific to the documentation engines that are being used, the transfer of information should be flexible. One idea is that every package can generate a file which describes the sets of documentation output it generates, assigned each a name and source documentation engine. For example, this might look something like this in the general form:

> 由于此导出和导入信息的内容与使用的文档引擎有关，因此信息的传输应该是灵活的。一个想法是，每个包都可以生成一个描述其生成的文档输出集的文件，为其分配一个名称和源文档引擎。例如，这可能会在一般形式中看起来像这样：

```
    {% highlight yaml %}
    package_name: foo
    documentation_artifacts:
      sphinx:
        foo-default:
          output_dir: '/'
        foo:
          output_dir: '/sphinx/'
      doxygen:
        foo:
          output_dir: '/doxygen/'
          xml_output_dir: '/doxygen_xml/'
    {% endhighlight %}
```

This example is extremely declarative, but the developer would not need to explicitly fill this file out, but instead it could be dynamically generated by the documentation process and tooling. In the above example, the output is categorized hierarchically by documentation engine, then a named run of the engine, and then the details of that run. The details of the run can be a documentation engine specific opaque set of settings.

> 这个例子非常具有声明性，但是开发人员不需要显式地填写这个文件，而是可以由文档处理和工具动态生成。在上面的例子中，输出按文档引擎分类，然后是引擎的命名运行，然后是该运行的详细信息。运行的细节可以是文档引擎特定的不透明设置。

### Documentation Input

Additional information, e.g. a base path, could be paired with the above example output and given as input to another package. With a base path and this example output, other packages should be able to successfully cross reference the `foo` package if their documentation engine supports this. So in addition to the default configurations, the documentation inputs for a package would be a series of base paths and "documentation artifact manifests" for each of the package's build, run, and doc dependencies.

> 除了默认配置以外，对于一个包的文档输入还包括一系列的基本路径和每个包的构建、运行和文档依赖项的“文档工件清单”。可以将附加信息（例如基本路径）与上述示例输出配对，并将其作为另一个包的输入。如果其文档引擎支持此功能，则有了基本路径和此示例输出，其他包应该能够成功地对 `foo` 包进行交叉引用。

## The Documentation Job

There are two processes which need to be detailed in order to successfully document different kinds of packages. The process with the largest scope has been described in this article as the documentation job. The documentation job is the process of preparing the operating system for documentation a particular package, invoking the documentation process, and then dealing with the results. The rough outline of the process is:

> 为了成功记录不同类型的包，需要详细说明两个过程。本文将范围最大的过程描述为文档工作。文档工作是准备操作系统以文档某个特定的包的过程，调用文档过程，然后处理结果的过程。这个过程的大致描述是：

- Build-like dependencies are installed.
- The package is built, unless the user opts-out.
- Run-like and doc dependencies are installed.
- The package is documented using the documentation process.
- The documentation which has been installed is packaged or moved to hosting.

<div class="alert alert-warning" markdown="1">
    TODO: Fill in details about the documentation job
</div>

## The Documentation Process

The documentation process consists of the series of actions which must be preformed in order to generate documentation for a single package. The process starts with an environment that has all of the dependencies for the package resolved and in which the package has already been built. This process constitutes what happens for the "doc target" of the build tools. The build tools will perform these steps in the documentation process:

> 文档流程包括一系列必须为单个软件包生成文档的操作。流程从一个已经解决了软件包所有依赖关系并且已经构建的环境开始。这个过程构成了构建工具的“doc 目标”的发生情况。构建工具将执行文档流程中的这些步骤：

- Create a list of requested and implicit runs of documentation engines.
- For each run, the appropriate default configurations and inputs are compiled.
- For each run, documentation engine specific execution occurs.
- For each run, the generated documentation output is cataloged and copied to the install destination.
- The cataloged output meta data is compiled into a single documentation manifest for the package and installed.

The implicit runs would encompass the default documentation engine.

> 隐式运行将包括默认的文档引擎。

<div class="alert alert-warning" markdown="1">
    TODO: Fill in details about the documentation process
</div>

## User Stories

This section will look at the documentation system from the point of view of the users, in this case package developers and package consumers, by constructing some common and uncommon scenarios in order to gain a better understanding of the requirements.

> 这一部分将从用户的角度来看文档系统，在这种情况下是包开发者和包消费者，通过构建一些常见和不常见的场景来更好地理解需求。

### Discovering Packages Through Documentation

Scenario:

> 场景：

A "package consumer", someone who is looking for packages to use in their ROS system, hears about a package that sounds interesting to them, e.g. `wall_e_plant_detection`. She searches for `wall_e_plant_detection` with her favorite search engine and finds a page which summarizes or references the package. After a while she realizes that she can go to `packages.ros2.org/wall_e_plant_detection` get redirected to the latest version of the package for the current ROS distribution, which might end up going to something more specific like `http://packages.ros2.org/en/jade/latest/wall_e_plant_detection/index.html`. The page summarizes or references all the information about the package that can be compiled by the documentation system, e.g. Code documentation, Tutorials, wiki, jobs on the farm, etc. This page has also been customized by the developer to include a longer description and more content like custom links to external resources.

> 一个“软件包消费者”，他正在寻找可以用于 ROS 系统的软件包，听说了一个听起来很有趣的软件包，例如“wall_e_plant_detection”。她使用她最喜欢的搜索引擎搜索“wall_e_plant_detection”，找到了一个概括或引用该软件包的页面。过了一会儿，她意识到可以转到“packages.ros2.org/wall_e_plant_detection”，转到当前 ROS 发行版的软件包的最新版本，可能会转到更具体的地址，例如“[http://packages.ros2.org/en/jade/latest/wall_e_plant_detection/index.html](http://packages.ros2.org/en/jade/latest/wall_e_plant_detection/index.html)”。该页面概括或引用由文档系统编译的所有软件包信息，例如代码文档、教程、wiki、农场工作等。开发者还对该页面进行了自定义，添加了更长的描述和更多内容，比如自定义外部资源链接。

This ROS package landing page would be similar to the landing pages for Ubuntu packages, e.g. `http://packages.ubuntu.com/trusty/libboost-all-dev`. From here the user can discover general and API documentation, tutorials, other versions, dependencies, dependents, provided resources, etc., all for this package.

> 这个 ROS 包着陆页面将类似于 Ubuntu 包的着陆页面，例如 [http://packages.ubuntu.com/trusty/libboost-all-dev](http://packages.ubuntu.com/trusty/libboost-all-dev)。从这里，用户可以发现此包的一般和 API 文档、教程、其他版本、依赖项、依赖项、提供的资源等等。

---

tip: translate by openai@2023-05-30mailto:openai@2023-05-30 22:56:52
...

`packages.ros2.org` is just an example. Based on the implementation of the infrastructure for this site, something more like `docs.ros2.org` may make more sense. Even `wiki.ros2.org`, if it is implemented more as a wiki with static pages embedded throughout.

One question is whether or not the package developer should be able to customize this page at all. Ideally the developer could hook into this process and add more stuff than what is in the `package.xml`'s description. This could be accomplished by either having the ability to import something like a `README.rst` file or the ability for the developer to edit the contents of the landing page directly as a file in their repository.

> 一个问题是包开发者是否应该能够自定义此页面。理想情况下，开发者可以钩入此过程，并添加比 `package.xml` 描述中更多的东西。这可以通过允许开发者导入类似 `README.rst` 文件的方式来实现，或者允许开发者直接在他们的存储库中作为文件编辑着页面的内容来实现。

### Documentation for a Released Package

Scenario:

> 情景：

After providing zero extra documentation or configuration a package developer releases their package to take advantage of the binary packaging provided for released packages. After the release has been processed by the build farm, the package will have a discoverable landing page with as much information extracted from the package as is possible.

> 提供零额外文档或配置后，软件包开发者可以发布软件包，以利用发布软件包提供的二进制打包。发布处理完成后，软件包将具有可发现的着陆页，其中包含尽可能从软件包中提取的信息。

This is a slight improvement on the ROS 1 system, because in ROS 1 the package developer would have to additionally go to the wiki and create a package with the `PackageHeader` macro in it in order to gain the same effect.

> 这是对 ROS 1 系统的轻微改进，因为在 ROS 1 中，包开发者还必须额外转到 wiki 上，使用 `PackageHeader` 宏创建一个包，才能达到同样的效果。

### Documentation for an Unreleased Package

Scenario:

> 情景：

A package developer would like to make their package discoverable by others and have their documentation hosted, but has not taken the time to do a proper release of the package. She submits a pull request to the ROS distribution file to add a "doc" entry for her package(s). This doc entry points to repository which contains her package(s) on her main development branch. Later the build farm, triggered either by a commit or a periodic timer, cloned her repository and ran the documentation job on the package(s). Documentation was generated based on her package's configurations and the result is uploaded to the doc servers for others to find.

> 开发者希望让自己的软件包可以被其他人发现并拥有文档服务，但他们没有花费时间做一个正式的发布。他们提交了一个拉取请求到 ROS 分发文件中，为他们的软件包添加一个“doc”条目。这个 doc 条目指向一个包含他们软件包的主要开发分支的仓库。后来，构建农场，无论是通过提交或定时器触发，克隆他们的仓库并且在软件包上运行文档任务。文档是根据他们的软件包配置生成的，结果被上传到文档服务器，供其他人查找。

The scenario shows that users should be able to take advantage of as much of the documentation system as possible without releasing their package.

> 用户应该尽可能多地利用文档系统，而无需发布其软件包。

### Maintaining Multiple Versions of Documentation

Scenario:

> 场景：

A package developer adds to the public API in a backwards compatible way during a ROS release, e.g. between versions `1.1.0` and `1.2.0` for the Jade ROS distribution. Because of this change, the package developer would like to make the documentation for both versions of the package available to their users. So in addition to specifying a branch of their VCS repository that should be documented periodically using a doc entry, she explicitly specifies version `0.1.0` to be generated and kept around. So now there are three versions of the documentation for Jade, her latest branch `jade-devel`, version `0.1.0`, and the most recent released version `0.2.0`. When users browse to her package's documentation they will see three options for versions of documentation for Jade, `latest`, `0.1.0`, and `0.2.0`.

> 一个软件包开发者在 ROS 发布期间，以向后兼容的方式添加到公共 API，例如在 Jade ROS 发行版的 1.1.0 和 1.2.0 之间。由于这种变化，软件包开发者希望为他们的用户提供两个版本的软件包文档。因此，除了使用文档条目定期指定其 VCS 存储库的分支外，她还明确指定生成并保留版本 0.1.0。现在，Jade 有三个版本的文档，最新的分支 jade-devel，版本 0.1.0 和最新发布的版本 0.2.0。当用户浏览他们的软件包文档时，他们将看到三个版本的 Jade 文档选项：“最新版本”，“0.1.0”和“0.2.0”。

Currently the ROS 1 infrastructure only allows for one version of documentation per package per ROS distribution. This works for most cases, but a more flexible option for packages which change during the life time of distributions would be to have multiple released versions as well as a floating "latest" version if desired. To do this would require capturing which VCS tags should be documented, where the tags map to older versions of the software. This would be in addition to the information we already capture in the "doc" entry which covers a tag or branch to document and the "release" entry which tells us the latest version of the package currently released but not previous versions. This idea is borrowed from the way the [https://readthedocs.org/](https://readthedocs.org/) on-line documentation service operates.

> 目前，ROS 1 基础设施只允许每个 ROS 分发包有一个版本的文档。这适用于大多数情况，但对于在发行版生命周期内发生变化的包，一个更灵活的选择是有多个发布版本以及浮动的“最新”版本（如果需要）。要做到这一点，需要捕获哪些 VCS 标签应该被记录下来，其中标签映射到软件的旧版本。除此之外，我们还将在“doc”条目中捕获信息，其中包含文档的标记或分支，以及“release”条目，其中告诉我们当前发布的包的最新版本，但不是以前的版本。这个想法借鉴了 [https://readthedocs.org/](https://readthedocs.org/)在线文档服务正在运行。

## Documentation Requirements

The functional requirements were arrived at by building on the experience of the ROS 1 documentation system and practices, while keeping in mind some non-functional requirements.

> 功能需求是在 ROS 1 文档系统和实践的经验基础上得出的，同时牢记一些非功能需求。

### Non-Functional Requirements

Listed in no particular order, the documentation system should be...

> 文件系统不按特定顺序列出，应。。。

- _scalable_ by ensuring that a default, minimal output for each package is generated with zero configuration.
- _usable_ by reusing information in the package manifest to minimize duplication of information throughout.
- _extensible_ by ensuring that many documentation engines can be supported and that special elements can be automatically documented, e.g. ROS messages, launch files, node parameters, etc.
- _standard compliant and conventional_ by reusing tools which already exist where possible.
- _accessible and consistent_ by providing common configuration items in order to reduce effort for developers and to improve consistency across packages.
- _configurable_ by giving the developer access to each documentation engine's configuration, as not to hinder their ability to customize the output.
- _maintainable_ by reusing specific documentation engine's configuration mechanism where possible.
- _efficient_ by allowing the developer to opt-out of steps which are not required for their package.
- _safe_ by identifying undesirable results and notifying the developer.
- _discoverable_ by having easy to read and understand URL schemes and by facilitating the storage of and switching between multiple versions of the documentation.
- _stable_ by having conventions about documentation layout, warning when they are violated, and enforcing them where possible.

These no-functional requirements, or qualities, of the system guided the following proposed functional requirements and system design.

> 这些系统的无功能需求或质量指导了以下提出的功能需求和系统设计。

### Functional Requirements

The above non-function requirements have suggestions at some of the more concrete function requirements. Listed in no particular order, the documentation system will...

> 上述非功能需求对一些更具体的功能需求提出了建议。不按特定顺序列出，文档系统将。。。

- support at least Sphinx and Doxygen.
- document each package, one at a time, in a topological order which respects `<doc_depend>` type dependencies.
- build each package before running documentation engines.
- allow developers to skip building their package before running documentation engines on it.
- run Sphinx by default.
- **_not_** allow the developer to skip running Sphinx on their package.
- provide a default Sphinx configuration for packages which do not provide one.
- provide a tool to generate the default Sphinx configuration, allowing the developer to modify it.
- validate the Sphinx settings and warn the developer in the case that a setting might cause a problem with the output.
- provide a mechanism in Sphinx to access and reuse information stored in the package manifest file.
- provide a mechanism in Sphinx to generate the "package page header" which summarizes the package and provides a consistent landing page for all packages (similar to the package header in the ROS 1 wiki).
- enforce that the index page for Sphinx follows a certain format which starts with the "package page header".
- enforce that reserved names are not used as pages or folders in the Sphinx layout, e.g. `msgs` which will contain ROS message documentation.
- run Doxygen by default.
- allow the developer to skip running Doxygen on their package.
- provide default Doxygen configuration for packages which do not provide them.
- provide a tool to generate the default Doxygen configuration, allowing the developer to modify them.
