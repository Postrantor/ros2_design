---
tip: translate by openai@2023-05-29 08:12:40
layout: default
title: IDL - Interface Definition and Language Mapping
permalink: articles/idl_interface_definition.html
abstract:
This describes defining interfaces using a subset of the [Interface Definition Language](https://www.omg.org/spec/IDL/) (IDL).
published: true
author: '[Dirk Thomas](https://github.com/dirk-thomas)'
date_written: 2019-03
last_modified: 2020-07
categories: Interfaces
Authors: {{ page.author }}
Date Written: {{ page.date_written }}
Last Modified: {% if page.last_modified %}{{ page.last_modified }}{% else %}{{ page.date_written }}{% endif %}
---
## Scope

This article identifies a subset of the [Interface Definition Language](https://www.omg.org/spec/IDL/) (IDL) that can be used to describe interfaces between components.

> 这篇文章确定了可用于描述组件之间接口的[接口定义语言](https://www.omg.org/spec/IDL/)（IDL）的子集。

Further it describes how the interfaces are used to generate code in C, C++ and Python.

> 进一步描述了如何使用接口来生成 C、C++ 和 Python 的代码。

## Supported subset of IDL

ROS 2 supports a subset of the [OMG IDL 4.2 specification](https://www.omg.org/spec/IDL/4.2).

> ROS 2 支持 [OMG IDL 4.2 规范](https://www.omg.org/spec/IDL/4.2) 的一个子集。

Whatever is not listed below is probably not supported at the moment (e.g. enums).

> 除下面列出的之外，目前可能不支持（例如枚举）。

### Lexical Conventions

#### 7.2.2 Comments

Both line comments (`//`) as well as block comments (`/* ... */`) are being supported.

> 两种注释（`//`）和块注释（`/* ... */`）都受支持。

#### 7.2.3 Identifiers

An identifier must start with an is an ASCII alphabetic characteran followed by any number of ASCII alphabetic, digit and underscore (`_`) characters.

> 一个标识符必须以 ASCII 字母字符开头，后面可以跟任意数量的 ASCII 字母字符、数字和下划线（\_）字符。

#### 7.2.6 Literals

All of the following literals are supported:

> 所有以下文字都支持：

- Integer
- Character
- String
- Floating-point
- Fixed-point

### Preprocessing

At the moment there is no preprocessing happening when reading the `.idl files.

> 目前读取 `.idl 文件时没有预处理过程。

### Building Blocks

#### 7.4.6.4.1.4 Imports

Imports must be used to reference other `.idl` file which declare data types used in this `.idl` file.

> 必须使用导入来引用其他的 `.idl` 文件，以声明数据类型。在这个 `.idl` 文件中使用

#### 7.4.1.4.2 Modules

Each module must contain at least one definition and they can be nested.

> 每个模块至少要包含一个定义，这些定义可以嵌套。

For ROS interfaces the first module level commonly represents the package name, the second module level distinguishes the type of the interface (`msg`, `srv`,

> 对于 ROS 接口，第一个模块级别通常代表包名。 第二个模块级别区分接口的类型（`msg`、`srv`） `action`).

#### 7.4.1.4.3 Constants

#### 7.4.1.4.4.4.1 Structures

A structure must contain at least one member.

> 一个结构必须包含至少一个成员。

### Basic Types

#### 7.4.1.4.4.2.1 Integer Types

```
| IDL type            | Value range        |
| ------------------- | ------------------ |
| short               | -2^15 ... 2^15 - 1 |
| unsigned short      | 0 ... 2^16 - 1     |
| long                | -2^31 ... 2^31 - 1 |
| unsigned long       | 0 ... 2^32 - 1     |
| long long           | -2^63 ... 2^63 - 1 |
| unsigned long long  | 0 ... 2^64 - 1     |
```

#### 7.4.1.4.4.2.2 Floating-Point Types

```
| IDL type    | Format                                      |
| ----------- | ------------------------------------------- |
| float       | IEEE single-precision floating point number |
| double      | IEEE double-precision floating point number |
| long double | IEEE double-extended floating-point number  |
```

#### 7.4.1.4.4.2.3 Char Type

```
| IDL type | Value range                                                                            |
| -------- | -------------------------------------------------------------------------------------- |
| char     | A 8-bit single-byte character with a numerical value between 0 and 255 (see 7.2.6.2.1) |
```

The type can store a single-byte character from any byte-oriented code set, or when used in an array, encode a multi-byte character from a multi-byte code set.

> 这种类型可以存储来自任何字节导向编码集的单字节字符。在数组中使用时，从多字节编码集中编码多字节字符。

#### 7.4.1.4.4.2.4 Wide Char Type

```
| IDL type | Value range             |
| -------- | ----------------------- |
| wchar    | A 16-bit wide character |
```

While the IDL spec only defines the size of wchar as implementation-dependent the DDS-XTypes specification 1.2 defines it with 16-bit.

> 而 IDL 规范只定义了 wchar 的大小为实现相关的。DDS-XTypes 规范 1.2 将其定义为 16 位。

#### 7.4.1.4.4.2.5 Boolean Type

```
| IDL type | Value range                      |
| -------- | -------------------------------- |
| boolean  | One of the values TRUE and FALSE |
```

#### 7.4.1.4.4.2.6 Octet Types

```
| IDL type | Value range  |
| ---------| ------------ |
| octet    | opaque 8-bit |
```

#### 7.4.13.4.4 8-bits Integers

```
| IDL type | Value range      |
| ---------| ---------------- |
| int8     | -2^7 ... 2^7 - 1 |
| uint8    | 0 ... 2^8 - 1    |
```

#### 7.4.13.4.5 Explicitly-named Integer Types

```
| IDL type       | Equivalent IDL type |
| -------------- | ------------------- |
| int16          | short               |
| uint16         | unsigned short      |
| int32          | long                |
| uint32         | unsigned long       |
| int64          | long long           |
| uint64         | unsigned long long  |
```

### Template Types

#### 7.4.1.4.4.3.1 Sequences

```
| IDL type               | Value range                                                |
| ---------------------- | ---------------------------------------------------------- |
| sequence\<type\_spec>  | sequence of items of the specific type\_spec               |
|                        | the sequence is unbounded and no maximum size is specified |
| sequence<type_spec, N> | sequence of of up to N items of the specified type\_spec   |
|                        | the sequence is bounded and contain between 0 and N items  |
```

#### 7.4.1.4.4.3.2 Strings

```
| IDL type | Value range                  |
| -------- | ---------------------------- |
| string   | sequence of char except null |
```

#### 7.4.1.4.4.3.3 Wstrings

```
| IDL type | Value range                   |
| -------- | ----------------------------- |
| wstring  | sequence of wchar except null |
```

### Constructed Types

#### 7.4.1.4.4.4.1 Structures

A structure is a grouping of at least one member.

> 一个结构至少由一个成员组成。

#### 7.4.1.4.4.4.3 Enumerations

An enumerated type consist of an ordered list of enumerators.

> 一个枚举类型由一个有序的枚举器列表组成。

#### 7.4.1.4.4.5 Arrays

A multidimensional, fixed-size array is defined by the type of each item and the explicit sizes for each dimension. For now only a one-dimensional, fixed-size array is supported though.

> 一个多维、固定大小的数组由每个项目的类型和每个维度的明确大小定义。
> 现在只支持一维固定大小的数组。

### Annotations

The syntax for arbitrary annotations is supported. How each annotation type is being handled depends on the code generation described below.

> 支持任意注解的语法。取决于下面描述的代码生成，每种注释类型的处理方式是什么。

## Code Generation

```
<div class="alert alert-warning" markdown="1">
  <b>TODO:</b> All of this too
</div>
```

### Constraint Checking

Generated code for messages is only guaranteed to enforce constraints when a message is published. For example, there might not be an error when a field constrained to be a fixed size array is assigned an array with the wrong size. This could be inconsistent across client library implementations depending on language features and performance cost. In the future any client library may add additional constraint checking when a field is set or modified. Users of generated message code should assume constraints could be enforced at any time to be compatible with such a change.

> 生成的消息代码只有在发布消息时才能保证强制执行约束。例如，当将固定大小的数组分配给大小不正确的数组时，可能不会出错。这可能会因语言特性和性能成本而在客户端库实现中出现不一致。在未来，任何客户端库在设置或修改字段时都可能添加额外的约束检查。用户使用生成的消息代码应该假设可以随时强制执行约束以与此类变更兼容。

### Type Mapping

The next table defines how IDL types are mapped to the following programming languages:

> 下表定义了 IDL 类型如何映射到以下编程语言：

```
* C11 (or higher)
* C++11 (or higher)
* Python 3 (or higher)

| IDL type    | C type           | C++ type                       | Python type          |
| --------    | -----------      | ------------------------------ | -------------------- |
| float       | float            | float                          | float                |
| double      | double           | double                         | float                |
| long double | long double      | long double[<sup>2</sup>](#ld) | float                |
| char        | unsigned char    | unsigned char                  | str with length 1    |
| wchar       | char16\_t        | char16\_t                      | str with length 1    |
| boolean     | \_Bool           | bool                           | bool                 |
| octet       | unsigned char    | std::byte[<sup>1</sup>](#byte) | bytes with length 1  |
| int8        | int8\_t          | int8\_t                        | int                  |
| uint8       | uint8\_t         | uint8\_t                       | int                  |
| int16       | int16\_t         | int16\_t                       | int                  |
| uint16      | uint16\_t        | uint16\_t                      | int                  |
| int32       | int32\_t         | int32\_t                       | int                  |
| uint32      | uint32\_t        | uint32\_t                      | int                  |
| int64       | int64\_t         | int64\_t                       | int                  |
| uint64      | uint64\_t        | uint64\_t                      | int                  |
```

1. <a name="byte"></a>If std::byte is not available then unsigned char is used instead.
2. <a name="ld"></a>Users should research the support for `long double` with their choice of middleware and platform.

> 如果没有 std::byte，则使用无符号字符代替。
> 用户应该研究他们选择的中间件和平台对 `long double` 的支持情况。

For example, it is only [64 bits when using Visual Studio](https://docs.microsoft.com/en-us/cpp/c-language/type-long-double?view=vs-2017).

> 例如，使用 Visual Studio 时只有 64 位。

The next table defines how IDL templated and constructed types are mapped to the programming languages (unless specified otherwise below).

> 下表定义了 IDL 模板和构造类型如何映射到编程语言（除非另有说明）。

When specified `T` is either one of the types above or an IDL struct.

> 当指定的 T 是上述类型之一或 IDL 结构时。`N` is the upper limit of a bounded type.

```
| IDL type       | C type                            | C++ type         | Python type |
| -------------- | --------------------------------- | ---------------- | ----------- |
| T[N]           | T[N]                              | std::array<T, N> | list        |
| sequence\<T>   | struct {size\_t, T * }            | std::vector\<T>  | list        |
| sequence<T, N> | struct {size\_t, T * }, size\_t N | std::vector\<T>  | list        |
| string         | char *                            | std::string      | str         |
| string\<N>     | char *                            | std::string      | str         |
| wstring        | char16\_t *                       | std::u16string   | str         |
| wstring\<N>    | char16\_t *                       | std::u16string   | str         |
```

These array and sequence types have special mappings. If a cell is blank then the default mapping is used.

> 这些数组和序列类型有特殊的映射。如果单元格为空，则使用默认映射。

```
| IDL type                     |   | C type                            | C++ type       | Python type                                     |   |
| ---------------------------- | - | --------------------------------- | -------------- | ----------------------------------------------- | - |
| T[N] | for numeric types T:<br>float, double,<br>int8, uint8,<br>int16, uint16,<br>int32, uint32,<br>int64, uint64 | - | - | numpy.ndarray(<br>&nbsp;&nbsp;shape=(N, ),<br>&nbsp;&nbsp;dtype=numpy.DT) | where DT is determined by T:<br>float -> float32,<br>double -> float64,<br>intX -> intX,<br>uintX -> uintX |
| sequence\<T><br>sequence<T, N> | for numeric types T:<br>float, double,<br>int8, uint8,<br>int16, uint16,<br>int32, uint32,<br>int64, uint64 | - | - | array.array(typecode=TC) | where TC is determined by T:<br>float -> f,<br>double -> d,<br>int8 -> b, uint8 -> B,<br>int16 -> h, uint16 -> H,<br>int32 -> l, uint32 -> L,<br>int64 -> q, uint64 -> Q |
| octet[N]                     |   | -                                 | -              | bytes                                           | |
| sequence\<octet>              |   | -                                 | -              | bytes                                           | |
| sequence<octet, N>           |   | -                                 | -              | bytes                                           | |
```

### Standardized Annotations

#### 8.3.2.1 @key Annotation

While the key annotation doesn't affect the generated ROS data types directly it is being passed through to the (DDS) vendor specific code generators.

> 当关键注释不直接影响生成的 ROS 数据类型时，它将被传递到（DDS）供应商特定的代码生成器中。

#### 8.3.3.1 @default Annotation

The default value is being used to initialize struct members.

> 默认值被用来初始化结构体成员。

#### 8.3.5.1 @verbatim Annotation

When the value `comment` is passed as the `language` parameter the text parameter is used as the docblock for the annotated element across all supported programming languages.

> 当将值 `comment` 作为 `language` 参数传入时，text 参数将被用作所有支持的编程语言中注释元素的 docblock。
